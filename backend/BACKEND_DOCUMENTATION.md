# TerraScope Backend API Documentation

## Overview

TerraScope Backend is a Flask-based REST API that provides geospatial observation data services. The API supports Django-generated token authentication, allowing users with active subscriptions from the frontend to access satellite observation data, datasets, and related services.

## Table of Contents

- [Technology Stack](#technology-stack)
- [Project Structure](#project-structure)
- [Features](#features)
- [Installation](#installation)
- [Configuration](#configuration)
- [Database Models](#database-models)
- [API Endpoints](#api-endpoints)
- [Authentication](#authentication)
- [Django Integration](#django-integration)
- [Error Handling](#error-handling)
- [Testing](#testing)
- [Deployment](#deployment)

---

## Technology Stack

- **Framework**: Flask 3.1.2
- **Database**: SQLite (development) / PostgreSQL (production recommended)
- **ORM**: SQLAlchemy 3.1.1
- **Serialization**: Marshmallow 3.20.1, Flask-Marshmallow 0.15.0
- **Authentication**: Flask-JWT-Extended 4.6.0, PyJWT 2.10.1
- **API Documentation**: Flasgger 0.9.7.1 (Swagger UI)
- **CORS**: Flask-CORS 6.0.1
- **Python**: 3.14+

### Dependencies

```
flask==3.1.2
flask-sqlalchemy==3.1.1
marshmallow==3.20.1
flask-marshmallow==0.15.0
marshmallow-sqlalchemy==0.29.0
flask-jwt-extended==4.6.0
flask-cors==6.0.1
flasgger==0.9.7.1
PyYAML==6.0.2
werkzeug==3.1.3
pyjwt==2.10.1
```

---

## Project Structure

```
backend/
├── app.py                    # Main Flask application
├── requirements.txt          # Python dependencies
├── README.md                # Basic setup instructions
├── .vscode/                 # VS Code configuration
│   └── settings.json        # Python interpreter settings
│
├── env/                     # Virtual environment (Flask packages)
│   ├── Scripts/            # Executables
│   └── Lib/                # Installed packages
│
└── instance/                # SQLite database storage
    └── terrascope_dev.db   # Development database
```

---

## Features

### 1. Django Token Integration ⭐ NEW
- ✅ Validates JWT tokens generated by Django frontend
- ✅ Shared JWT secret key with Django
- ✅ Custom `@django_token_required` decorator
- ✅ User/subscription info extraction from tokens
- ✅ Token expiration validation

### 2. RESTful API Endpoints
- ✅ CRUD operations for observations
- ✅ Dataset management
- ✅ Advanced filtering (date range, coordinates)
- ✅ Bulk operations support
- ✅ Pagination

### 3. Authentication & Authorization
- ✅ Flask JWT authentication (legacy)
- ✅ Django token authentication (integrated)
- ✅ User login/registration
- ✅ Token refresh mechanism
- ✅ Protected endpoints

### 4. Data Management
- ✅ Satellite observation records
- ✅ Dataset collections
- ✅ User accounts
- ✅ Spectral indices storage
- ✅ Coordinate-based queries

### 5. API Documentation
- ✅ Swagger UI at `/apidocs`
- ✅ Interactive API testing
- ✅ Endpoint documentation
- ✅ Request/response examples

### 6. CORS Support
- ✅ Configured for Django frontend
- ✅ Allows cross-origin requests
- ✅ Secure headers configuration

---

## Installation

### Prerequisites

- Python 3.14 or higher
- pip (Python package manager)
- Git

### Step-by-Step Setup

1. **Navigate to backend directory**
   ```bash
   cd backend
   ```

2. **Create virtual environment**
   ```bash
   python -m venv env
   ```

3. **Activate virtual environment**
   
   **Windows (Git Bash):**
   ```bash
   source env/Scripts/activate
   ```
   
   **Windows (CMD):**
   ```cmd
   env\\Scripts\\activate.bat
   ```
   
   **Linux/Mac:**
   ```bash
   source env/bin/activate
   ```

4. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   ```

5. **Set environment variables (optional)**
   ```bash
   export JWT_SECRET_KEY="your-super-secret-jwt-key-change-in-production"
   ```
   
   **Note**: Must match Django's JWT_SECRET_KEY for token integration

6. **Run the application**
   ```bash
   python app.py
   ```

7. **Access the API**
   - API Base: http://127.0.0.1:5000
   - Swagger Docs: http://127.0.0.1:5000/apidocs
   - Health Check: http://127.0.0.1:5000/health

---

## Configuration

### Flask Configuration

```python
# JWT Configuration (Django Integration)
app.config['JWT_SECRET_KEY'] = os.getenv('JWT_SECRET_KEY', 'your-super-secret-jwt-key')
app.config['DJANGO_JWT_SECRET'] = os.getenv('JWT_SECRET_KEY', 'your-super-secret-jwt-key')
app.config['DJANGO_JWT_ALGORITHM'] = 'HS256'

# Flask-JWT-Extended (Legacy endpoints)
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(seconds=30)
app.config["JWT_REFRESH_TOKEN_EXPIRES"] = timedelta(days=7)

# Database
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///terrascope_dev.db"
app.config["SQLALCHEMY_ECHO"] = True
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False

# General
app.config['JSON_AS_ASCII'] = False
app.config["SECRET_KEY"] = "CHANGE_ME_SECRET_KEY"
```

### CORS Configuration

```python
CORS(app, resources={
    r"/api/*": {
        "origins": ["http://127.0.0.1:8000", "http://localhost:8000"],
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"]
    }
})
```

### Swagger Configuration

```python
app.config['SWAGGER'] = {
    'title': 'TerraScope API',
    'uiversion': 3
}
```

---

## Database Models

### Dataset Model

Represents a collection of related observations.

**Table**: `datasets`

**Fields**:
- `id` (Integer, Primary Key) - Unique identifier
- `name` (String, 120 chars, Required) - Dataset name
- `description` (String, 255 chars, Optional) - Description text

**Schema**: `DatasetSchema` - Marshmallow schema for JSON serialization

**Example**:
```json
{
  "id": 1,
  "name": "Sentinel-2 L2A",
  "description": "Atmospheric corrected surface reflectance data"
}
```

### Observation Model

Stores satellite observation data with filtering capabilities.

**Table**: `observations`

**Fields**:
- `id` (Integer, Primary Key) - Unique identifier
- `timestamp` (DateTime, Required) - Observation date/time
- `timezone` (String, 50 chars) - Timezone string
- `coordinates` (String, 100 chars) - Format: "lat=40.7,long=-74.0"
- `satellite_id` (String, 50 chars) - Satellite identifier
- `spectral_indices` (Text) - JSON string of spectral data
- `notes` (Text) - Additional notes

**Schema**: `ObservationSchema` - Marshmallow schema

**Example**:
```json
{
  "id": 1,
  "timestamp": "2025-01-15T14:30:00",
  "timezone": "UTC",
  "coordinates": "lat=51.5074,long=-0.1278",
  "satellite_id": "SAT-001",
  "spectral_indices": "{\"NDVI\": 0.75, \"EVI\": 0.68}",
  "notes": "Clear sky conditions"
}
```

### User Model

Stores user authentication information (for legacy Flask JWT).

**Table**: `users`

**Fields**:
- `id` (Integer, Primary Key) - Unique identifier
- `username` (String, 80 chars, Unique, Required) - Username
- `password_hash` (String, 120 chars, Required) - Hashed password

**Methods**:
- `set_password(password)` - Hash and store password
- `check_password(password)` - Verify password

**Schema**: `UserSchema` - Marshmallow schema

**Note**: This model is for Flask's internal authentication. Django tokens use Django's User model.

---

## API Endpoints

### Django Integration Endpoints (Protected with Django Tokens)

#### GET /api/me
Get current user information from Django-generated token.

**Authentication**: Bearer token (Django-generated)

**Response**:
```json
{
  "message": "Token validated successfully!",
  "user_id": 5,
  "username": "Francis007",
  "email": "francis@example.com",
  "subscription_id": 23,
  "product_id": 4,
  "product_name": "SO2",
  "tier": "so2",
  "api_calls_limit": 10000,
  "data_limit_mb": 100,
  "token_id": "9b61abcf-5224-49ee-af6f-6637a34fe320",
  "issued_at": "2025-12-06T01:01:39",
  "expires_at": "2025-12-06T01:11:16"
}
```

**Example**:
```bash
curl -H "Authorization: Bearer YOUR_DJANGO_TOKEN" \
  http://127.0.0.1:5000/api/me
```

#### GET /api/observations
Get satellite observations using Django token authentication.

**Authentication**: Bearer token (Django-generated)

**Query Parameters**:
- `start_date` (string) - ISO 8601 format: "2025-01-01T00:00:00"
- `end_date` (string) - ISO 8601 format: "2025-12-31T23:59:59"
- `lat` (float) - Latitude filter
- `long` (float) - Longitude filter
- `limit` (integer) - Max results (default: 100)

**Response**:
```json
{
  "user": {
    "id": 5,
    "product": "SO2"
  },
  "count": 10,
  "limit": 100,
  "observations": [...]
}
```

**Example**:
```bash
curl -H "Authorization: Bearer YOUR_DJANGO_TOKEN" \
  "http://127.0.0.1:5000/api/observations?limit=10&start_date=2025-01-01T00:00:00"
```

---

### Flask JWT Endpoints (Legacy Authentication)

#### POST /auth/login
Login with username/password to get Flask JWT tokens.

**Request Body**:
```json
{
  "username": "testuser",
  "password": "testpass"
}
```

**Response**:
```json
{
  "message": "Login successful",
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
  "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
  "user_id": "1"
}
```

#### POST /auth/refresh
Refresh Flask access token using refresh token.

**Headers**:
```
Authorization: Bearer REFRESH_TOKEN
```

**Response**:
```json
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc..."
}
```

---

### Observation Endpoints

#### GET /observations
Get all observations with optional filtering (requires Flask JWT).

**Authentication**: Flask JWT required

**Query Parameters**:
- `start_date` - ISO 8601 timestamp
- `end_date` - ISO 8601 timestamp
- `lat` - Latitude
- `long` - Longitude

**Response**: Array of observation objects

#### POST /observations
Create a new observation.

**Authentication**: Flask JWT required

**Request Body**:
```json
{
  "timestamp": "2025-01-15T14:30:00",
  "timezone": "UTC",
  "coordinates": "lat=51.5074,long=-0.1278",
  "satellite_id": "SAT-001",
  "spectral_indices": "{\"NDVI\": 0.75}",
  "notes": "Clear conditions"
}
```

**Response**: Created observation object

#### GET /observations/<id>
Get single observation by ID.

**Authentication**: Flask JWT required

**Response**: Observation object

#### PUT /observations/<id>
Replace observation (all fields required).

**Authentication**: Flask JWT required

#### PATCH /observations/<id>
Partial update observation (only changed fields).

**Authentication**: Flask JWT required

#### POST /observations/bulk
Create multiple observations at once.

**Authentication**: Flask JWT required

**Request Body**:
```json
{
  "observations": [
    {
      "timestamp": "2025-01-15T14:30:00",
      "coordinates": "lat=51.5074,long=-0.1278",
      ...
    },
    ...
  ]
}
```

**Response**: Array of created observations

---

### Dataset Endpoints

#### GET /datasets
List all datasets.

**Response**: Array of dataset objects

#### POST /datasets/demo
Create a demo dataset (for testing ORM).

**Response**: Created dataset object

---

### Utility Endpoints

#### GET /
Root endpoint - API status.

**Response**:
```json
{
  "message": "TerraScope API is running",
  "status": "ok"
}
```

#### GET /health
Health check endpoint.

**Response**:
```json
{
  "status": "ok"
}
```

#### GET /protected
Test endpoint for Flask JWT authentication.

**Authentication**: Flask JWT required

**Response**:
```json
{
  "message": "You are viewing protected data",
  "user_id": "1"
}
```

---

### Test Endpoints

For testing error handling:

- `POST /test-bad-request` - Returns 400 error
- `GET /test-unauthorized` - Returns 401 error
- `GET /test-forbidden` - Returns 403 error
- `POST /test-validate` - Returns 422 validation error
- `GET /test-rate-limit` - Returns 429 rate limit error
- `GET /test-server-error` - Returns 500 server error
- `GET /test-unavailable` - Returns 503 service unavailable

---

## Authentication

### Django Token Authentication (Recommended)

The `@django_token_required` decorator validates JWT tokens generated by the Django frontend.

**How it works**:

1. **Django generates token** when user purchases subscription
2. **User includes token** in API requests: `Authorization: Bearer <token>`
3. **Flask validates token** using shared JWT secret
4. **Token claims checked**:
   - Signature verification
   - Expiration check
   - Required fields (user_id, subscription_id, product_id, jti)
5. **Token data attached** to `request.token_data` for use in endpoint

**Decorator implementation**:

```python
@app.get("/api/observations")
@django_token_required
def get_observations_django():
    # Access token data
    token_data = request.token_data
    user_id = token_data.get('user_id')
    
    # Use token info in business logic
    ...
```

**Token Validation**:
- ✅ Signature verification with Django's JWT secret
- ✅ Expiration timestamp check
- ✅ Required claims validation
- ✅ User/subscription information extraction

**Error Responses**:

Missing token (401):
```json
{
  "error": "Authorization Required",
  "message": "No authorization header provided..."
}
```

Invalid token (401):
```json
{
  "error": "Invalid Token",
  "message": "Token validation failed: Signature verification failed"
}
```

Expired token (401):
```json
{
  "error": "Token Expired",
  "message": "Your subscription token has expired..."
}
```

### Flask JWT Authentication (Legacy)

For internal Flask authentication (not integrated with Django).

**Login Flow**:
1. POST to `/auth/login` with username/password
2. Receive access_token (30 seconds) and refresh_token (7 days)
3. Use access_token in `Authorization: Bearer <token>` header
4. Refresh when expired using `/auth/refresh`

**Protected Endpoints** use `@jwt_required()` decorator.

---

## Django Integration

### Configuration Synchronization

**CRITICAL**: Both Django and Flask must share the same JWT secret key.

**Django (`frontend/terrascope/settings.py`)**:
```python
JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'your-super-secret-jwt-key')
JWT_ALGORITHM = 'HS256'
```

**Flask (`backend/app.py`)**:
```python
app.config['DJANGO_JWT_SECRET'] = os.getenv('JWT_SECRET_KEY', 'your-super-secret-jwt-key')
app.config['DJANGO_JWT_ALGORITHM'] = 'HS256'
```

### Token Flow

```
Django Frontend (Port 8000)
        ↓
User purchases subscription
        ↓
Django generates JWT token
        ↓
Token contains: user_id, subscription_id, product info, limits, expiry
        ↓
User copies token from subscription page
        ↓
User makes API call to Flask (Port 5000)
        ↓
Flask @django_token_required validates token
        ↓
Flask serves data based on subscription tier
```

### Integration Testing

1. **Start Django**: `cd frontend && python manage.py runserver`
2. **Start Flask**: `cd backend && python app.py`
3. **Login to Django**: http://127.0.0.1:8000
4. **Purchase subscription** (use test card: 4242 4242 4242 4242)
5. **Generate token** from subscription detail page
6. **Test Flask API** with token:

```bash
curl -H "Authorization: Bearer YOUR_TOKEN" \
  http://127.0.0.1:5000/api/me
```

See `DJANGO_FLASK_INTEGRATION.md` for complete integration guide.

---

## Error Handling

### Global Error Handlers

Flask automatically handles common errors with custom responses:

**400 Bad Request**:
```json
{
  "error": "Bad Request",
  "message": "The request was malformed or invalid",
  "code": 400
}
```

**401 Unauthorized**:
```json
{
  "error": "Unauthorized",
  "message": "Authentication required",
  "code": 401
}
```

**403 Forbidden**:
```json
{
  "error": "Forbidden",
  "message": "You do not have permission to access this resource",
  "code": 403
}
```

**404 Not Found**:
```json
{
  "error": "Not Found",
  "message": "The requested resource was not found",
  "code": 404
}
```

**500 Internal Server Error**:
```json
{
  "error": "Internal Server Error",
  "message": "An unexpected error occurred",
  "code": 500
}
```

### Custom Error Handling

Endpoints return appropriate HTTP status codes:
- `200 OK` - Success
- `201 Created` - Resource created
- `400 Bad Request` - Invalid input
- `401 Unauthorized` - Authentication failed
- `403 Forbidden` - No permission
- `404 Not Found` - Resource not found
- `422 Unprocessable Entity` - Validation error
- `429 Too Many Requests` - Rate limit exceeded
- `500 Internal Server Error` - Server error
- `503 Service Unavailable` - Service down

---

## Testing

### Manual Testing with cURL

**Health Check**:
```bash
curl http://127.0.0.1:5000/health
```

**Login (Flask JWT)**:
```bash
curl -X POST http://127.0.0.1:5000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"testpass"}'
```

**Get Observations (Flask JWT)**:
```bash
curl -H "Authorization: Bearer YOUR_FLASK_TOKEN" \
  http://127.0.0.1:5000/observations
```

**Get User Info (Django Token)**:
```bash
curl -H "Authorization: Bearer YOUR_DJANGO_TOKEN" \
  http://127.0.0.1:5000/api/me
```

### Testing with Postman

1. **Import collection** or create new requests
2. **Set Authorization**:
   - Type: Bearer Token
   - Token: Your JWT token
3. **Test endpoints** interactively
4. **Save requests** for reuse

### Swagger UI Testing

1. Visit http://127.0.0.1:5000/apidocs
2. Click "Authorize" button
3. Enter: `Bearer YOUR_TOKEN`
4. Test endpoints interactively

### Automated Testing

Create test scripts:

```python
import requests

# Test health endpoint
response = requests.get('http://127.0.0.1:5000/health')
assert response.status_code == 200
assert response.json()['status'] == 'ok'

# Test with Django token
token = "YOUR_DJANGO_TOKEN"
headers = {'Authorization': f'Bearer {token}'}
response = requests.get('http://127.0.0.1:5000/api/me', headers=headers)
assert response.status_code == 200
```

---

## Deployment

### Production Checklist

1. **Security**:
   ```python
   app.config['DEBUG'] = False
   app.config['JWT_SECRET_KEY'] = os.environ['JWT_SECRET_KEY']
   ```

2. **Database**:
   - Use PostgreSQL instead of SQLite
   - Set up connection pooling
   - Enable database backups

3. **WSGI Server**:
   - Use Gunicorn or uWSGI
   - Not Flask development server

4. **Reverse Proxy**:
   - Nginx or Apache
   - SSL/TLS certificate
   - Rate limiting

5. **Environment Variables**:
   ```bash
   export JWT_SECRET_KEY="production-secret"
   export DATABASE_URL="postgresql://..."
   export FLASK_ENV="production"
   ```

6. **CORS**:
   - Update origins to production domains
   - Enable only necessary methods

7. **Monitoring**:
   - Error tracking (Sentry)
   - Performance monitoring
   - API usage metrics

### Deployment with Gunicorn

```bash
pip install gunicorn
gunicorn -w 4 -b 0.0.0.0:5000 app:app
```

### Nginx Configuration

```nginx
server {
    listen 80;
    server_name api.terrascope.com;

    location / {
        proxy_pass http://127.0.0.1:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### Docker Deployment

```dockerfile
FROM python:3.14-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:5000", "app:app"]
```

---

## Common Tasks

### Add New Observation

```bash
curl -X POST http://127.0.0.1:5000/observations \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "timestamp": "2025-12-06T12:00:00",
    "coordinates": "lat=40.7,long=-74.0",
    "satellite_id": "SAT-001"
  }'
```

### Filter by Date Range

```bash
curl -H "Authorization: Bearer YOUR_TOKEN" \
  "http://127.0.0.1:5000/api/observations?start_date=2025-01-01T00:00:00&end_date=2025-12-31T23:59:59"
```

### Create Multiple Observations

```bash
curl -X POST http://127.0.0.1:5000/observations/bulk \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "observations": [
      {"timestamp": "2025-01-01T10:00:00", ...},
      {"timestamp": "2025-01-02T10:00:00", ...}
    ]
  }'
```

---

## Troubleshooting

### Issue: Token Validation Fails
**Symptoms**: 401 "Invalid Token" errors
**Solutions**:
- Verify JWT_SECRET_KEY matches Django
- Check token hasn't expired
- Ensure correct Authorization header format: `Bearer <token>`

### Issue: CORS Errors
**Symptoms**: Browser blocks API requests from Django
**Solutions**:
- Verify Django origin in CORS config
- Check allowed methods include your request method
- Enable credentials if needed

### Issue: Database Not Found
**Symptoms**: "No such table" errors
**Solutions**:
```python
# In Python shell or add to app.py temporarily
with app.app_context():
    db.create_all()
```

### Issue: Import Errors
**Symptoms**: "Module not found" errors
**Solutions**:
```bash
# Verify virtual environment is activated
source env/Scripts/activate  # Windows Git Bash
# Reinstall requirements
pip install -r requirements.txt
```
