from flask import Flask, jsonify, request
from flask_jwt_extended import (
    JWTManager,
    jwt_required,
    create_access_token,
    create_refresh_token,
    get_jwt_identity,
    verify_jwt_in_request
)
from flask_cors import CORS

import json
import re
import datetime
import jwt
from functools import wraps
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow
from flasgger import Swagger
from datetime import datetime  
from werkzeug.security import generate_password_hash, check_password_hash  
from flask_jwt_extended import JWTManager, jwt_required, create_access_token, get_jwt_identity, verify_jwt_in_request

# Create the Flask application object
app = Flask(__name__)

# Enable CORS to allow Django frontend (running on port 8000) to call Flask API (port 5000)
CORS(app, resources={
    r"/api/*": {
        "origins": ["http://127.0.0.1:8000", "http://localhost:8000"],
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"]
    }
})

# Swagger / OpenAPI UI basic configuration
app.config['SWAGGER'] = {
    'title': 'TerraScope API',  # Title shown on Swagger UI page
    'uiversion': 3              # Use Swagger UI v3
}

# Attach Swagger to this Flask app so /apidocs (or configured route) will show docs
swagger = Swagger(app)

from datetime import datetime, timedelta  # <-- you already import datetime, just add timedelta
import os

# ========================================
# DJANGO INTEGRATION: JWT Configuration
# ========================================
# Use the SAME secret key as Django to validate tokens generated by Django
# This allows Django-generated subscription tokens to work with Flask API
app.config['JWT_SECRET_KEY'] = os.getenv('JWT_SECRET_KEY', 'your-super-secret-jwt-key-change-in-production')
app.config['DJANGO_JWT_SECRET'] = os.getenv('JWT_SECRET_KEY', 'your-super-secret-jwt-key-change-in-production')
app.config['DJANGO_JWT_ALGORITHM'] = 'HS256'

# Flask-JWT-Extended configuration (for Flask's own /auth/login endpoint)
jwt_manager = JWTManager(app)

# Token lifetimes (short access token to demo expiry easily)
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(seconds=30)   # or 60 seconds
app.config["JWT_REFRESH_TOKEN_EXPIRES"] = timedelta(days=7)      # refresh valid for a week


# ========================================
# DJANGO TOKEN VALIDATION DECORATOR
# ========================================
def django_token_required(f):
    """
    Custom decorator to validate Django-generated JWT tokens.
    This allows users who purchased subscriptions via Django to use their tokens with Flask API.
    
    Token should be passed in Authorization header: Bearer <token>
    
    The decorator validates:
    - Token signature using Django's JWT secret
    - Token expiration
    - Required claims (user_id, subscription_id, product_id)
    
    If valid, the decoded token data is available in the wrapped function.
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Get token from Authorization header
        auth_header = request.headers.get('Authorization', '')
        
        if not auth_header:
            return jsonify({
                'error': 'Authorization Required',
                'message': 'No authorization header provided. Please include: Authorization: Bearer <your-token>'
            }), 401
        
        # Extract token from "Bearer <token>" format
        parts = auth_header.split()
        if len(parts) != 2 or parts[0].lower() != 'bearer':
            return jsonify({
                'error': 'Invalid Authorization Header',
                'message': 'Authorization header must be in format: Bearer <token>'
            }), 401
        
        token = parts[1]
        
        try:
            # Decode and validate token using Django's secret key
            decoded = jwt.decode(
                token,
                app.config['DJANGO_JWT_SECRET'],
                algorithms=[app.config['DJANGO_JWT_ALGORITHM']]
            )
            
            # Verify required claims exist
            required_claims = ['user_id', 'subscription_id', 'product_id', 'jti']
            missing_claims = [claim for claim in required_claims if claim not in decoded]
            
            if missing_claims:
                return jsonify({
                    'error': 'Invalid Token',
                    'message': f'Token is missing required claims: {missing_claims}'
                }), 401
            
            # Check if token has expired
            if 'exp' in decoded:
                exp_timestamp = decoded['exp']
                if datetime.utcnow().timestamp() > exp_timestamp:
                    return jsonify({
                        'error': 'Token Expired',
                        'message': 'Your subscription token has expired. Please renew your subscription.'
                    }), 401
            
            # Token is valid! Attach decoded data to request context
            request.token_data = decoded
            
            return f(*args, **kwargs)
            
        except jwt.ExpiredSignatureError:
            return jsonify({
                'error': 'Token Expired',
                'message': 'Your subscription token has expired. Please renew your subscription.'
            }), 401
        except jwt.InvalidTokenError as e:
            return jsonify({
                'error': 'Invalid Token',
                'message': f'Token validation failed: {str(e)}'
            }), 401
        except Exception as e:
            return jsonify({
                'error': 'Authentication Error',
                'message': f'An error occurred while validating your token: {str(e)}'
            }), 401
    
    return decorated_function


# -----------------------------
# CONFIG
# -----------------------------
# Ensure JSON is returned as UTF-8 (allows non-ASCII characters correctly)
app.config['JSON_AS_ASCII'] = False
# Use SQLite database file called terrascope_dev.db in the local folder
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///terrascope_dev.db"
# Echo all SQL commands in the terminal (useful for debugging ORM behaviour)
app.config["SQLALCHEMY_ECHO"] = True
# Disable a deprecated SQLAlchemy tracking feature to avoid warnings
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
# General Flask secret key (used e.g. for sessions); here also labelled as JWT secret
app.config["SECRET_KEY"] = "CHANGE_ME_SECRET_KEY"  # JWT secret

# Create SQLAlchemy instance bound to the app (for defining models and queries)
db = SQLAlchemy(app)
# Create Marshmallow instance bound to the app (for schemas)
ma = Marshmallow(app)

# -----------------------------
# DATABASE MODELS + SCHEMAS
# US-19: Dataset Model + US-10: Observation Model
# -----------------------------

# Dataset model represents a simple dataset in the database
class Dataset(db.Model):
    __tablename__ = "datasets"  # Table name in SQLite DB

    id = db.Column(db.Integer, primary_key=True)             # Unique ID per dataset
    name = db.Column(db.String(120), nullable=False)         # Name (required)
    description = db.Column(db.String(255), nullable=True)   # Optional description text

    def __repr__(self):
        # Helpful string representation when printing Dataset objects
        return f"<Dataset {self.id} - {self.name}>"


# Schema for turning Dataset objects into JSON and back
class DatasetSchema(ma.SQLAlchemyAutoSchema):
    class Meta:
        model = Dataset         # Connect schema to Dataset model
        load_instance = True    # When loading, create real Dataset instances


# Single-dataset schema (one object)
dataset_schema = DatasetSchema()
# Multi-dataset schema (list of objects)
datasets_schema = DatasetSchema(many=True)


# US-10: Observation Model (for satellite data with filtering support)
# This model stores details of each satellite observation
class Observation(db.Model):
    __tablename__ = "observations"  # Table name in SQLite DB

    id = db.Column(db.Integer, primary_key=True)                   # Unique ID per observation
    timestamp = db.Column(db.DateTime, nullable=False)             # Exact date/time of observation
    timezone = db.Column(db.String(50), nullable=True)             # Time zone string
    coordinates = db.Column(db.String(100), nullable=True)         # e.g., "lat=40.7,long=-74.0"
    satellite_id = db.Column(db.String(50), nullable=True)         # Which satellite captured this
    spectral_indices = db.Column(db.Text, nullable=True)           # JSON string of spectral data
    notes = db.Column(db.Text, nullable=True)                      # Free-form notes/comments

    def __repr__(self):
        # Helpful representation for debugging / logs
        return f"<Observation {self.id} - {self.timestamp}>"


# Schema for Observation model
class ObservationSchema(ma.SQLAlchemyAutoSchema):
    class Meta:
        model = Observation      # Link to Observation model
        load_instance = True     # Load back as Observation objects


# Single observation schema
observation_schema = ObservationSchema()
# Multiple observations schema
observations_schema = ObservationSchema(many=True)


# US-13: User Model (for authentication; stores hashed passwords)
# This model represents a user who can log into the API and get a JWT token
class User(db.Model):
    __tablename__ = "users"  # Table name in DB

    id = db.Column(db.Integer, primary_key=True)                # Unique user ID
    username = db.Column(db.String(80), unique=True, nullable=False)   # Username must be unique
    password_hash = db.Column(db.String(120), nullable=False)   # Securely stored password hash

    def __repr__(self):
        # Show username when printing the object
        return f"<User {self.username}>"

    # Helper method to hash and store a password
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    # Helper method to verify a given password against the stored hash
    def check_password(self, password):
        return check_password_hash(self.password_hash, password)


# US-13: Marshmallow schema for User (for potential serialization)
class UserSchema(ma.SQLAlchemyAutoSchema):
    class Meta:
        model = User
        load_instance = True
        exclude = ('password_hash',)  # Make sure password hash is never sent in API responses


# Single-user schema
user_schema = UserSchema()
# Multi-user schema
users_schema = UserSchema(many=True)


# US-19: Create database tables once (now includes users)
tables_created = False  # Flag so we only create tables once per app lifetime

@app.before_request
def create_tables_once():
    """
    This function runs before every request.
    It makes sure the database tables exist and seeds a default test user once.
    """
    global tables_created
    if not tables_created:
        # Create all tables for Dataset, Observation, User, etc.
        db.create_all()
        # If there are no users yet, create a simple test user for JWT login demos
        if User.query.count() == 0:
            test_user = User(username='testuser')  # Default username
            test_user.set_password('testpass')     # Default password (hashed inside)
            db.session.add(test_user)
            db.session.commit()
        # Mark that tables and seed user have been created
        tables_created = True


# ============================================
# JWT IMPLEMENTATION (now using flask-jwt-extended)
# ============================================
# JWT config and User model are above; login endpoint and protected routes below


# US-11: Helper function for quarter boundary checks
def get_current_quarter_start():
    """
    US-11: Calculate the start date of the current quarter
    Returns datetime object for the first day of current quarter at 00:00:00
    """
    now = datetime.now()
    current_month = now.month
    
    # Determine quarter start month (1, 4, 7, or 10)
    if current_month <= 3:
        quarter_start_month = 1  # Q1: Jan-Mar
    elif current_month <= 6:
        quarter_start_month = 4  # Q2: Apr-Jun
    elif current_month <= 9:
        quarter_start_month = 7  # Q3: Jul-Sep
    else:
        quarter_start_month = 10  # Q4: Oct-Dec
    
    # Return first day of quarter at midnight
    return datetime(now.year, quarter_start_month, 1, 0, 0, 0)


# ============================================
# ERROR HANDLERS (9 total)
# ============================================
# Each of these functions standardises error responses in JSON format.

@app.errorhandler(400)
def bad_request(error):
    # Handle invalid requests (wrong data, bad JSON, etc.)
    return jsonify({"error": "Bad Request", "message": error.description or "Your input is invalid", "code": 400}), 400


@app.errorhandler(401)
def unauthorized(error):
    # Handle missing/invalid authentication
    return jsonify({"error": "Unauthorized", "message": error.description or "Authentication required", "code": 401}), 401


@app.errorhandler(403)
def forbidden(error):
    # Handle user being authenticated but not allowed to access resource
    return jsonify({"error": "Forbidden", "message": error.description or "Access denied", "code": 403}), 403


@app.errorhandler(404)
def not_found(error):
    # Handle wrong URL / endpoint
    return jsonify({"error": "Not Found", "message": error.description or "Endpoint not found", "code": 404}), 404


@app.errorhandler(405)
def method_not_allowed(error):
    # Handle wrong HTTP method used on valid endpoint
    return jsonify({"error": "Method Not Allowed", "message": "Use valid HTTP method", "code": 405}), 405


@app.errorhandler(422)
def unprocessable_entity(error):
    # Handle data that is syntactically correct but fails validation rules
    return jsonify({"error": "Unprocessable Entity", "message": error.description or "Validation failed", "code": 422}), 422


@app.errorhandler(429)
def too_many_requests(error):
    # Handle rate limiting (too many requests in short time)
    return jsonify({"error": "Too Many Requests", "message": error.description or "Rate limit exceeded", "code": 429}), 429


@app.errorhandler(500)
def internal_error(error):
    # Handle unexpected server errors
    return jsonify({"error": "Internal Server Error", "message": "Something went wrong", "code": 500}), 500


@app.errorhandler(503)
def service_unavailable(error):
    # Handle service unavailable (e.g., maintenance or temporary failure)
    return jsonify({"error": "Service Unavailable", "message": error.description or "Server temporarily down", "code": 503}), 503


# Force 500 handler to work even in debug mode
@app.errorhandler(Exception)
def handle_exception(e):
    """
    Catch-all handler for any uncaught exception that is NOT a standard HTTPException.
    This ensures the client always gets a clean JSON error instead of a stack trace.
    """
    from werkzeug.exceptions import HTTPException
    # If it's an HTTPException (like 404/401), let its own handler deal with it
    if isinstance(e, HTTPException):
        return e

    # For everything else, return a generic 500 error in JSON
    return jsonify({
        "error": "Internal Server Error",
        "message": "Something went wrong, try again later",
        "code": 500
    }), 500


# ============================================
# MAIN ENDPOINTS
# ============================================

@app.get("/health")
def health():
    """
    Simple endpoint to confirm the API is running.
    Used as a health check (US-05) and documented for Swagger (US-06).
    ---
    tags:
      - System
    responses:
      200:
        description: API is running
        schema:
          type: object
          properties:
            status:
              type: string
              example: ok
    """
    return jsonify({"status": "ok"}), 200


@app.get("/")
def root():
    # Root endpoint, returns a basic message confirming the TerraScope API startup
    return jsonify({"message": "TerraScope API is running", "status": "ok"}), 200


# ========================================
# DJANGO TOKEN VALIDATION ENDPOINTS
# ========================================

@app.get("/api/me")
@django_token_required
def get_user_info():
    """
    Get current user information from Django-generated token.
    This endpoint demonstrates Django token integration.
    
    To use this endpoint:
    1. Purchase a subscription on the Django website (http://127.0.0.1:8000)
    2. Generate an API token from your subscription page
    3. Use the token in Authorization header: Bearer <your-token>
    ---
    tags:
      - Django Integration
    security:
      - Bearer: []
    responses:
      200:
        description: User information from token
        schema:
          type: object
          properties:
            user_id:
              type: integer
            username:
              type: string
            email:
              type: string
            subscription_id:
              type: integer
            product_name:
              type: string
            tier:
              type: string
            api_calls_limit:
              type: integer
            data_limit_mb:
              type: integer
            token_expires_at:
              type: string
      401:
        description: Unauthorized - invalid or missing token
    """
    # Access the decoded token data attached by decorator
    token_data = request.token_data
    
    # Format expiry timestamp
    exp_timestamp = token_data.get('exp')
    exp_datetime = datetime.fromtimestamp(exp_timestamp) if exp_timestamp else None
    
    return jsonify({
        'message': 'Token validated successfully!',
        'user_id': token_data.get('user_id'),
        'username': token_data.get('username'),
        'email': token_data.get('email'),
        'subscription_id': token_data.get('subscription_id'),
        'product_id': token_data.get('product_id'),
        'product_name': token_data.get('product_name'),
        'tier': token_data.get('tier'),
        'api_calls_limit': token_data.get('api_calls_limit'),
        'data_limit_mb': token_data.get('data_limit_mb'),
        'token_id': token_data.get('jti'),
        'issued_at': datetime.fromtimestamp(token_data.get('iat')).isoformat() if token_data.get('iat') else None,
        'expires_at': exp_datetime.isoformat() if exp_datetime else None,
    }), 200


@app.get("/api/observations")
@django_token_required
def get_observations_django():
    """
    Get observations using Django-generated subscription token.
    This endpoint requires a valid subscription token from the Django website.
    
    Protected endpoint that returns satellite observation data for authenticated users.
    Users must have an active subscription to access this data.
    ---
    tags:
      - Django Integration
      - Observations
    security:
      - Bearer: []
    parameters:
      - name: start_date
        in: query
        type: string
        required: false
        description: ISO 8601 start of timestamp range
      - name: end_date
        in: query
        type: string
        required: false
        description: ISO 8601 end of timestamp range
      - name: lat
        in: query
        type: string
        required: false
        description: Latitude filter
      - name: long
        in: query
        type: string
        required: false
        description: Longitude filter
      - name: limit
        in: query
        type: integer
        required: false
        description: Maximum number of results (default 100)
    responses:
      200:
        description: List of observations
      401:
        description: Unauthorized - invalid or missing token
    """
    # Get user info from token
    token_data = request.token_data
    user_id = token_data.get('user_id')
    product_name = token_data.get('product_name')
    
    # Start query
    query = Observation.query
    
    # Apply filters from query parameters
    start_date_str = request.args.get('start_date')
    end_date_str = request.args.get('end_date')
    lat_str = request.args.get('lat')
    long_str = request.args.get('long')
    limit = request.args.get('limit', 100, type=int)
    
    # Filter by date range
    if start_date_str:
        try:
            start_date = datetime.fromisoformat(start_date_str.replace('Z', '+00:00'))
            query = query.filter(Observation.timestamp >= start_date)
        except ValueError:
            return jsonify({"error": "Invalid start_date format"}), 400
    
    if end_date_str:
        try:
            end_date = datetime.fromisoformat(end_date_str.replace('Z', '+00:00'))
            query = query.filter(Observation.timestamp <= end_date)
        except ValueError:
            return jsonify({"error": "Invalid end_date format"}), 400
    
    # Filter by coordinates
    if lat_str and long_str:
        try:
            lat = float(lat_str)
            lon = float(long_str)
            query = query.filter(
                Observation.latitude == lat,
                Observation.longitude == lon
            )
        except ValueError:
            return jsonify({"error": "Invalid lat/long format"}), 400
    
    # Apply limit
    observations = query.limit(limit).all()
    
    return jsonify({
        'user': {
            'id': user_id,
            'product': product_name
        },
        'count': len(observations),
        'limit': limit,
        'observations': observations_schema.dump(observations)
    }), 200


@app.post("/auth/login")
def login():
    """
    Login endpoint:
    - Takes username and password in JSON.
    - If correct, returns access + refresh JWT tokens.
    """
    data = request.get_json()
    if not data or 'username' not in data or 'password' not in data:
        return jsonify({
            "error": "Missing username or password",
            "code": 400
        }), 400

    username = data['username']
    password = data['password']

    user = User.query.filter_by(username=username).first()
    if user and user.check_password(password):
        # Short-lived access token
        access_token = create_access_token(identity=str(user.id))
        # Longer-lived refresh token
        refresh_token = create_refresh_token(identity=str(user.id))

        return jsonify({
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "Bearer",
            "user_id": user.id,
            "message": "Login successful"
        }), 200   # <-- status code here, not inside jsonify
    else:
        return jsonify({
            "error": "Invalid username or password",
            "code": 401
        }), 401
@app.post("/auth/refresh")
@jwt_required(refresh=True)
def refresh():
    """
    Use a valid refresh token to get a new access token.
    This supports the scenario:
    'Given token expired, when refreshed, then new token returned.'
    """
    # identity is the same user id we stored when creating the token
    current_user_id = get_jwt_identity()

    # issue a brand new access token
    new_access_token = create_access_token(identity=current_user_id)

    return jsonify({
        "access_token": new_access_token,
        "token_type": "Bearer",
        "message": "Access token refreshed successfully"
    }), 200


# US-13: GET /protected (simple protected endpoint for testing)
@app.get("/protected")
@jwt_required()  # This decorator forces a valid JWT token on the request
def protected():
    # Get the user id stored in the JWT token (as string)
    current_user_id = get_jwt_identity()
    return jsonify({
        "message": "Access granted",
        "user_id": int(current_user_id)  # Convert ID back to int before returning
    }), 200


# US-07: Standard HTTP Methods on /items
# -----------------------------
# DUMMY ITEM ROUTES
# -----------------------------

@app.get("/items")
def get_items():
    """
    Demo endpoint that returns an empty list of items.
    Used to show a working GET endpoint and documented in Swagger.
    ---
    tags:
      - Items
    responses:
      200:
        description: Returns a dummy list of items
        schema:
          type: object
          properties:
            message:
              type: string
            items:
              type: array
              items:
                type: object
    """
    return jsonify({
        "message": "GET OK",
        "items": []
    }), 200


@app.post("/items")
def create_item():
    """
    Demo POST endpoint that pretends to create an item.
    It returns a success message but does not actually store anything.
    ---
    tags:
      - Items
    responses:
      201:
        description: Dummy item created
        schema:
          type: object
          properties:
            message:
              type: string
            details:
              type: string
    """
    return jsonify({
        "message": "POST OK",
        "details": "Item created (dummy)"
    }, 201)


@app.put("/items/<int:item_id>")
def update_item(item_id):
    """
    Demo PUT endpoint that pretends to fully update an item.
    Uses a path parameter item_id for the item to update.
    ---
    tags:
      - Items
    parameters:
      - name: item_id
        in: path
        type: integer
        required: true
        description: ID of the item to update
    responses:
      200:
        description: Dummy item updated
        schema:
          type: object
          properties:
            message:
              type: string
            id:
              type: integer
            details:
              type: string
    """
    return jsonify({
        "message": "PUT OK",
        "id": item_id,
        "details": "Full update completed (dummy)"
    }), 200


@app.patch("/items/<int:item_id>")
def patch_item(item_id):
    """
    Demo PATCH endpoint that pretends to partially update an item.
    ---
    tags:
      - Items
    parameters:
      - name: item_id
        in: path
        type: integer
        required: true
        description: ID of the item to patch
    responses:
      200:
        description: Dummy item partially updated
        schema:
          type: object
          properties:
            message:
              type: string
            id:
              type: integer
            details:
              type: string
    """
    return jsonify({
        "message": "PATCH OK",
        "id": item_id,
        "details": "Partial update completed (dummy)"
    }), 200


@app.delete("/items/<int:item_id>")
def delete_item(item_id):
    """
    Demo DELETE endpoint that pretends to delete an item.
    ---
    tags:
      - Items
    parameters:
      - name: item_id
        in: path
        type: integer
        required: true
        description: ID of the item to delete
    responses:
      200:
        description: Dummy item deleted
        schema:
          type: object
          properties:
            message:
              type: string
            id:
              type: integer
            details:
              type: string
    """
    return jsonify({
        "message": "DELETE OK",
        "id": item_id,
        "details": "Item deleted (dummy)"
    }), 200


# US-11: PUT /observations/<id> - Full update (protected from historical edits)
@app.put("/observations/<int:obs_id>")
@jwt_required()
def update_observation_full(obs_id):
    """
    US-11: Full update (PUT) with historical data protection
    Returns 403 if observation is from previous quarter
    """
    try:
        # Fetch observation or return 404
        obs = Observation.query.get_or_404(obs_id)
        
        # US-11: Check if observation is historical (before current quarter)
        current_quarter_start = get_current_quarter_start()
        
        if obs.timestamp < current_quarter_start:
            return jsonify({
                "error": "Historical data cannot be modified",
                "message": f"Records before {current_quarter_start.date()} are immutable",
                "code": 403
            }), 403
        
        # Get request data
        data = request.get_json()
        
        if not data:
            return jsonify({
                'error': 'Empty request body',
                'code': 400
            }), 400
        
        # Validate all required fields are present for PUT
        required_fields = ['timestamp', 'timezone', 'coordinates', 'satellite_id', 'spectral_indices']
        missing_fields = [field for field in required_fields if field not in data]
        
        if missing_fields:
            return jsonify({
                'error': f'Missing required fields for full update: {", ".join(missing_fields)}',
                'code': 400
            }), 400
        
        # Validate spectral_indices is a dict
        if not isinstance(data['spectral_indices'], dict):
            return jsonify({
                'error': 'spectral_indices must be a JSON object',
                'code': 400
            }), 400
        
        # Validate and parse ISO 8601 timestamp
        timestamp_str = data['timestamp']
        iso8601_pattern = r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}'
        
        if not re.match(iso8601_pattern, timestamp_str):
            return jsonify({
                'error': 'Invalid timestamp format. Expected ISO 8601 (YYYY-MM-DDTHH:MM:SS)',
                'code': 400
            }), 400
        
        try:
            # Parse timestamp - handles Z, +00:00, milliseconds, etc.
            parsed_timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
            normalized_timestamp = parsed_timestamp.replace(tzinfo=None)
        except (ValueError, AttributeError):
            return jsonify({
                'error': 'Invalid timestamp format. Expected ISO 8601 (YYYY-MM-DDTHH:MM:SS)',
                'code': 400
            }), 400
        
        # Update all fields
        obs.timestamp = normalized_timestamp
        obs.timezone = data['timezone']
        obs.coordinates = data['coordinates']
        obs.satellite_id = data['satellite_id']
        obs.spectral_indices = json.dumps(data['spectral_indices'])
        obs.notes = data.get('notes')  # Optional field
        
        # Commit changes
        db.session.commit()
        
        # Return updated observation with 200 (not 201)
        return jsonify(observation_schema.dump(obs)), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'error': f'Failed to update observation: {str(e)}',
            'code': 500
        }), 500


# US-11: PATCH /observations/<id> - Partial update (protected from historical edits)
@app.patch("/observations/<int:obs_id>")
@jwt_required()
def update_observation_partial(obs_id):
    """
    US-11: Partial update (PATCH) with historical data protection
    Returns 403 if observation is from previous quarter
    """
    try:
        # Fetch observation or return 404
        obs = Observation.query.get_or_404(obs_id)
        
        # US-11: Check if observation is historical (before current quarter)
        current_quarter_start = get_current_quarter_start()
        
        if obs.timestamp < current_quarter_start:
            return jsonify({
                "error": "Historical data cannot be modified",
                "message": f"Records before {current_quarter_start.date()} are immutable",
                "code": 403
            }), 403
        
        # Get request data
        data = request.get_json()
        
        if not data:
            return jsonify({
                'error': 'Empty request body',
                'code': 400
            }), 400
        
        # Update only provided fields
        if 'timestamp' in data:
            timestamp_str = data['timestamp']
            iso8601_pattern = r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}'
            
            if not re.match(iso8601_pattern, timestamp_str):
                return jsonify({
                    'error': 'Invalid timestamp format. Expected ISO 8601 (YYYY-MM-DDTHH:MM:SS)',
                    'code': 400
                }), 400
            
            try:
                parsed_timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
                obs.timestamp = parsed_timestamp.replace(tzinfo=None)
            except (ValueError, AttributeError):
                return jsonify({
                    'error': 'Invalid timestamp format. Expected ISO 8601 (YYYY-MM-DDTHH:MM:SS)',
                    'code': 400
                }), 400
        
        if 'timezone' in data:
            obs.timezone = data['timezone']
        
        if 'coordinates' in data:
            obs.coordinates = data['coordinates']
        
        if 'satellite_id' in data:
            obs.satellite_id = data['satellite_id']
        
        if 'spectral_indices' in data:
            if not isinstance(data['spectral_indices'], dict):
                return jsonify({
                    'error': 'spectral_indices must be a JSON object',
                    'code': 400
                }), 400
            obs.spectral_indices = json.dumps(data['spectral_indices'])
        
        if 'notes' in data:
            obs.notes = data['notes']
        
        # Commit changes
        db.session.commit()
        
        # Return updated observation with 200 (not 201)
        return jsonify(observation_schema.dump(obs)), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'error': f'Failed to update observation: {str(e)}',
            'code': 500
        }), 500


# US-09: GET /observations with filtering support
@app.get("/observations")
@jwt_required()  # Protected: requires valid JWT in Authorization header
def get_observations():
    """
    Returns observations, optionally filtered by date range and/or location.
    This implements US-09: parameter-based filtering.
    ---
    tags:
      - Observations
    parameters:
      - name: start_date
        in: query
        type: string
        required: false
        description: ISO 8601 start of timestamp range (e.g., 2025-11-01T00:00:00)
      - name: end_date
        in: query
        type: string
        required: false
        description: ISO 8601 end of timestamp range (e.g., 2025-11-30T23:59:59)
      - name: lat
        in: query
        type: string
        required: false
        description: Latitude used in coordinates filter
      - name: long
        in: query
        type: string
        required: false
        description: Longitude used in coordinates filter
    responses:
      200:
        description: List of observations (possibly filtered)
        schema:
          type: array
          items:
            type: object
      400:
        description: Invalid query parameter values
        schema:
          type: object
          properties:
            error:
              type: string
            code:
              type: integer
    """
    # Get the current logged-in user ID from the JWT (not used in filter yet but available)
    current_user_id = get_jwt_identity()
    # You could convert to int if you tied observations to specific users
    # user_id = int(current_user_id)
    
    # Start with all observation records
    query = Observation.query

    # Read query parameters for filtering
    start_date_str = request.args.get('start_date')  # e.g., "2025-11-01T00:00:00"
    end_date_str = request.args.get('end_date')      # e.g., "2025-11-30T23:59:59"
    lat_str = request.args.get('lat')                # e.g., "40.7"
    long_str = request.args.get('long')              # e.g., "-74.0"

    # Filter by start date if provided
    if start_date_str:
        try:
            start_date = datetime.fromisoformat(start_date_str.replace('Z', '+00:00'))
            query = query.filter(Observation.timestamp >= start_date)
        except ValueError:
            return jsonify({
                "error": "Invalid start_date format. Use ISO 8601 (e.g., 2025-11-01T00:00:00)",
                "code": 400
            }), 400

    # Filter by end date if provided
    if end_date_str:
        try:
            end_date = datetime.fromisoformat(end_date_str.replace('Z', '+00:00'))
            query = query.filter(Observation.timestamp <= end_date)
        except ValueError:
            return jsonify({
                "error": "Invalid end_date format. Use ISO 8601 (e.g., 2025-11-30T23:59:59)",
                "code": 400
            }), 400

    # Filter by exact coordinates if both lat and long are provided
    if lat_str and long_str:
        location_filter = f"lat={lat_str},long={long_str}"
        query = query.filter(Observation.coordinates == location_filter)
    elif lat_str or long_str:
        # If only one of lat/long is provided, return an error
        return jsonify({
            "error": "Both 'lat' and 'long' parameters are required for location filtering",
            "code": 400
        }), 400

    # Execute the query and serialize results to JSON
    results = query.all()
    return jsonify(observations_schema.dump(results)), 200


# US-12: Bulk create observations
@app.post("/observations/bulk")
def bulk_create_observations():
    """
    Bulk create observations in one request (US-12).
    If any record is invalid, the whole operation fails and errors are returned.
    ---
    tags:
      - Observations
    consumes:
      - application/json
    parameters:
      - name: body
        in: body
        required: true
        description: List of observation objects to create
        schema:
          type: array
          items:
            type: object
            properties:
              timestamp:
                type: string
                description: ISO 8601 timestamp
              timezone:
                type: string
              coordinates:
                type: string
                description: "e.g., lat=53.5,long=-2.4"
              satellite_id:
                type: string
              spectral_indices:
                type: object
              notes:
                type: string
    responses:
      201:
        description: All observations created successfully
        schema:
          type: object
          properties:
            message:
              type: string
            created_count:
              type: integer
            records:
              type: array
              items:
                type: object
      400:
        description: Bulk insert failed due to validation errors
        schema:
          type: object
          properties:
            message:
              type: string
            errors:
              type: array
              items:
                type: object
                properties:
                  record:
                    type: integer
                  error:
                    type: string
    """
    # Read JSON body from the request
    data = request.get_json()

    # Ensure the payload is a list (array) of observation objects
    if not isinstance(data, list):
        return jsonify({
            "error": "Bad Request",
            "message": "Expected a list of observation objects",
            "code": 400
        }), 400

    created = []  # Will store successfully created Observation objects
    errors = []   # Will store any validation errors per record

    # Loop through each record in the input array
    for index, item in enumerate(data):
        # Define required fields for each observation
        required = ["timestamp", "timezone", "coordinates", "satellite_id"]
        # Check which required fields are missing
        missing = [f for f in required if f not in item]

        if missing:
            # Record validation error but do not create this record
            errors.append({
                "record": index,
                "error": f"Missing required fields: {', '.join(missing)}"
            })
            continue

        # Try to parse timestamp; if invalid, record an error for this item
        try:
            timestamp = datetime.fromisoformat(item["timestamp"].replace("Z", "+00:00"))
        except ValueError:
            errors.append({
                "record": index,
                "error": "Invalid timestamp format. Use ISO 8601"
            })
            continue

        # Build Observation instance from provided data
        obs = Observation(
            timestamp=timestamp,
            timezone=item.get("timezone"),
            coordinates=item.get("coordinates"),
            satellite_id=item.get("satellite_id"),
            spectral_indices=json.dumps(item.get("spectral_indices")),
            notes=item.get("notes")
        )

        # Stage object for insertion
        db.session.add(obs)
        created.append(obs)

    # If any errors occurred, roll back everything (no records saved)
    if errors:
        db.session.rollback()
        return jsonify({
            "message": "Bulk insert failed",
            "errors": errors
        }), 400

    # If all records valid, commit everything in one transaction
    db.session.commit()

    # Return success message and the created records
    return jsonify({
        "message": "Bulk insert successful",
        "created_count": len(created),
        "records": observations_schema.dump(created)
    }), 201


# US-10: POST /observations - Create single observation
@app.post("/observations")
@jwt_required()
def create_observation():
    """
    Create new geospatial observation
    US-10: Store Geospatial Observation Data
    ---
    tags:
      - Observations
    consumes:
      - application/json
    parameters:
      - name: body
        in: body
        required: true
        description: Observation data to create
        schema:
          type: object
          required:
            - timestamp
            - timezone
            - coordinates
            - satellite_id
            - spectral_indices
          properties:
            timestamp:
              type: string
              description: ISO 8601 timestamp
            timezone:
              type: string
            coordinates:
              type: string
            satellite_id:
              type: string
            spectral_indices:
              type: object
            notes:
              type: string
    responses:
      201:
        description: Observation created successfully
      400:
        description: Validation error
      500:
        description: Server error
    """
    try:
        # Get JSON data from request
        data = request.get_json()
        
        # Check if request body is empty
        if not data:
            return jsonify({
                'error': 'Empty request body or missing required fields',
                'code': 400
            }), 400
        
        # Define required fields
        required_fields = ['timestamp', 'timezone', 'coordinates', 'satellite_id', 'spectral_indices']
        
        # Validate required fields
        missing_fields = []
        invalid_fields = []
        
        for field in required_fields:
            if field not in data:
                missing_fields.append(field)
            elif data[field] is None:
                invalid_fields.append(f"{field} (cannot be null)")
            elif isinstance(data[field], str) and not data[field].strip():
                invalid_fields.append(f"{field} (cannot be empty)")
        
        # Return error if validation fails
        if missing_fields:
            return jsonify({
                'error': f'Missing required field: {missing_fields[0]}' if len(missing_fields) == 1 
                        else f'Missing required fields: {", ".join(missing_fields)}',
                'code': 400
            }), 400
        
        if invalid_fields:
            return jsonify({
                'error': f'Invalid or empty value for required field: {invalid_fields[0]}',
                'code': 400
            }), 400
        
        # Validate spectral_indices is a dict
        if not isinstance(data['spectral_indices'], dict):
            return jsonify({
                'error': 'spectral_indices must be a JSON object',
                'code': 400
            }), 400
        
        # Validate and parse ISO 8601 timestamp
        timestamp_str = data['timestamp']
        
        # More flexible ISO 8601 pattern (accepts with/without milliseconds, timezone)
        iso8601_pattern = r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}'
        if not re.match(iso8601_pattern, timestamp_str):
            return jsonify({
                'error': 'Invalid timestamp format. Expected ISO 8601 (YYYY-MM-DDTHH:MM:SS)',
                'code': 400
            }), 400
        
        # Parse timestamp - handles Z, +00:00, milliseconds, etc.
        try:
            # Replace 'Z' with '+00:00' for proper parsing
            parsed_timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
            # Store without timezone info (normalized)
            normalized_timestamp = parsed_timestamp.replace(tzinfo=None)
        except (ValueError, AttributeError) as e:
            return jsonify({
                'error': 'Invalid timestamp format. Expected ISO 8601 (YYYY-MM-DDTHH:MM:SS)',
                'code': 400
            }), 400
        
        # Create new observation with normalized timestamp
        new_observation = Observation(
            timestamp=normalized_timestamp,
            timezone=data['timezone'],
            coordinates=data['coordinates'],
            satellite_id=data['satellite_id'],
            spectral_indices=json.dumps(data['spectral_indices']),
            notes=data.get('notes')
        )
        
        # Save to database
        db.session.add(new_observation)
        db.session.commit()
        
        # Return success response
        return jsonify({
            'message': 'Observation created successfully',
            'observation': observation_schema.dump(new_observation)
        }), 201
        
    except json.JSONDecodeError:
        return jsonify({
            'error': 'Invalid JSON format',
            'code': 400
        }), 400
        
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'error': f'Failed to create observation: {str(e)}',
            'code': 500
        }), 500


# US-10: GET /observations/<id> - Retrieve a single observation by ID
@app.get("/observations/<int:obs_id>")
@jwt_required()  # Protected: requires valid JWT
def get_observation_by_id(obs_id):
    """
    Returns a single observation by its ID.
    Used for US-10 AC3 testing to verify ISO 8601 timestamp format.
    ---
    tags:
      - Observations
    parameters:
      - name: obs_id
        in: path
        type: integer
        required: true
        description: ID of the observation to retrieve
    responses:
      200:
        description: Single observation object
        schema:
          type: object
          properties:
            id:
              type: integer
            timestamp:
              type: string
              description: ISO 8601 formatted timestamp
            timezone:
              type: string
            coordinates:
              type: string
            satellite_id:
              type: string
            spectral_indices:
              type: string
            notes:
              type: string
      404:
        description: Observation not found
        schema:
          type: object
          properties:
            error:
              type: string
            code:
              type: integer
    """
    # Fetch observation by ID or return 404 if not found
    obs = Observation.query.get_or_404(obs_id)
    
    # Return the observation as JSON
    return jsonify(observation_schema.dump(obs)), 200


# ============================================
# TEST ENDPOINTS (For verifying error handlers)
# ============================================

@app.post("/test-bad-request")
def test_bad_request():
    # This endpoint intentionally raises a 400 BadRequest to test error handler
    from werkzeug.exceptions import BadRequest
    raise BadRequest("Invalid JSON format or missing required fields")


@app.get("/test-unauthorized")
def test_unauthorized():
    # Intentionally raise a 401 Unauthorized error to test handler
    from werkzeug.exceptions import Unauthorized
    raise Unauthorized("Invalid or missing authentication token")


@app.get("/test-forbidden")
def test_forbidden():
    # Intentionally raise a 403 Forbidden error to test handler
    from werkzeug.exceptions import Forbidden
    raise Forbidden("You do not have permission to access this resource")


@app.post("/test-validate")
def test_validate():
    # Intentionally raise a 422 UnprocessableEntity to test validation error format
    from werkzeug.exceptions import UnprocessableEntity
    raise UnprocessableEntity("Data validation failed")


@app.get("/test-rate-limit")
def test_rate_limit():
    # Intentionally raise 429 TooManyRequests to test rate limit response
    from werkzeug.exceptions import TooManyRequests
    raise TooManyRequests("You have made too many requests. Please wait before trying again")


@app.get("/test-server-error")
def test_server_error():
    # Force a generic exception to see our global 500 handler in action
    raise Exception("Simulated server crash")


@app.get("/test-unavailable")
def test_unavailable():
    # Intentionally raise 503 ServiceUnavailable
    from werkzeug.exceptions import ServiceUnavailable
    raise ServiceUnavailable("Service is temporarily unavailable")


# ============================================
# NOTES
# ============================================
# Use @jwt_required() on any endpoint that should require login/JWT.
# Example test:
# 1) POST /auth/login with JSON {"username":"testuser","password":"testpass"}
# 2) Copy access_token from response
# 3) Call protected endpoints with header: Authorization: Bearer <access_token>


# ============================================
# US-22: Simple ORM demo for Dataset
# ============================================

@app.post("/datasets/demo")
def create_demo_dataset():
    """
    Quick demo endpoint to show ORM insert with SQLAlchemy for Dataset.
    Creates a 'Demo dataset' row in the datasets table.
    ---
    tags:
      - Datasets
    responses:
      201:
        description: Demo dataset created using SQLAlchemy ORM
    """
    demo = Dataset(
        name="Demo dataset",
        description="Created via SQLAlchemy ORM"
    )
    db.session.add(demo)   # Stage new Dataset object for insert
    db.session.commit()    # Save changes to DB
    return jsonify(dataset_schema.dump(demo)), 201


@app.get("/datasets")
def list_datasets():
    """
    Returns all Dataset records stored in the database.
    This shows how SQLAlchemy ORM is used to query and Marshmallow to serialize.
    ---
    tags:
      - Datasets
    responses:
      200:
        description: List of Dataset objects mapped from the database
    """
    all_datasets = Dataset.query.all()  # Query all dataset rows
    return jsonify(datasets_schema.dump(all_datasets)), 200


# -----------------------------
# RUN SERVER
# -----------------------------
if __name__ == "__main__":
    # Start the Flask development server with debug mode on
    app.run(debug=True)
